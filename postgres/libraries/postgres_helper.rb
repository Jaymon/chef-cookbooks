# https://docs.chef.io/libraries.html
# https://blog.chef.io/2014/03/12/writing-libraries-in-chef-cookbooks/

include ::Chef::Mixin::ShellOut


module PostgresHelper

  # handles reading/writing the pg_hba.conf file
  class PostgresHba

    attr_reader :path

    def initialize(version)

      @path = Postgres.get_hba_file(version)
      self.read_file!(Postgres.get_hba_file(version))

    end

    def read_file!(path)
      # holds each line of the original config file that was loaded with path, this
      # will be empty if no original config file was parsed
      @conf_lines = []

      # this is a list of dicts that have an index key that correlates to the index
      # in @conf_lines
      @conf_lookup = []

      @path = path

      ::File.read(path).each_line.with_index do |conf_line, index|
        conf_line.strip!
        @conf_lines << conf_line

        if conf_line =~ /^#/
          next

        elsif conf_line =~ /^\s*$/
          next

        else
          conf_line.strip!
          conn_type, database, user, remainder = conf_line.split(/\s+/, 4)
          ip6 = false

          if conn_type == 'local'
            method, options = remainder.split(/\s+/, 2)
            address = ''

          else
            address, method, options = remainder.split(/\s+/, 3)
            if address =~ /^::/
              ip6 = true
            end

          end

          options ||= ''

          d = {
            'index' => index,
            'ip6' => ip6,
            'connection' => conn_type,
            'database' => database,
            'user' => user,
            'method' => method,
            'address' => address,
            'options' => options
          }
          @conf_lookup << d
        end
      end

    end

    def set(row)
      default_row = {
        'method' => '',
        'address' => '',
        'options' => ''
      }
      index = -1

      @conf_lookup.each do |conf_row|
        is_match = true
        ['connection', 'database', 'user'].each do |k|
          if conf_row[k] != row[k]
            is_match = false
            break
          end
        end

        if is_match
          if row['address'] =~ /^::/
            if conf_row['ip6']
              index = conf_row['index']
              break
            end

          else
            index = conf_row['index']
            break
          end

        end

      end

      ncrow = default_row.merge(row)
      ncl = "#{ncrow['connection']} " + 
        "#{ncrow['database']} " + 
        "#{ncrow['user']} " + 
        "#{ncrow['address']} " +
        "#{ncrow['method']} " + 
        "#{ncrow['options']}"

      # NOTE -- if you set it to active=false and then back to active=true it
      # will make another row, this is a bug, but a forgivable one for now
      if !ncrow.fetch('active', true)
        ncl = "##{ncl}"
      end

      if index >= 0
        @conf_lines[index] = ncl

      else
        @conf_lines << ncl

        d = {"index" => @conf_lines.length}
        d.merge(ncrow)
        @conf_lookup[@conf_lines.length] = d

      end

    end

    def update!(rows)
      rows.each do |row|
        self.set(row)
      end
    end

    # convert everything to a string so it can be written to a file
    #
    # @returns [string]: all the configuration in the format needed
    def to_s()
      return @conf_lines.join("\n") + "\n"
    end

  end


  # handles writing a postgresql.conf compatible file to conf.d
  class PostgresConf

    attr_reader :path

    def initialize(version)

      # holds each line of the original config file that was loaded with path, this
      # will be empty if no original config file was parsed
      @conf_lines = [
        "# This file is auto-generated by postgres chef cookbook",
      ]

      # key => list of line numbers, holds the actual variable names and what line
      # they are found in conf_lines
      @conf_lookup = {}

      @version = version
      @path = Postgres.get_confd_file(version, "postgres")

    end

    # NOTE -- this is here but we don't use it (as of April 2020)
    def read_file!(path)

      if !::File.file?(path)
        raise ::Errno::ENOENT.new("#{path} does not exist")
      end

      # build a config file mapping we can manipulate
      ::File.read(path).each_line.with_index do |conf_line, index|
        if conf_line.match(/^\S+\s*=/)
          conf_var, conf_val = conf_line.split(/\s*=\s*/, 2)
          conf_val, conf_comment = conf_val.split(/#/, 2)

          #conf_val.rstrip!
          if conf_comment
            conf_comment.rstrip!
          else
            conf_comment = ''
          end

          if conf_var[0] == '#'
            conf_var = conf_var[1..-1]
          end
          @conf_lookup[conf_var] = [index, conf_comment]

        end

        @conf_lines << conf_line

      end

    end

    # set a value at key
    #
    # @param [string] key: the configuration value
    # @param [mixed] val: the value you want to set for key
    def set(key, val)

      #::Chef::Log.info("#{key} = #{val}")
      if val.is_a?(String)
        if val != "on" && val != "off"
          if !val.match(/^-?\d+/)
            val = "'#{val.gsub(/^'|'$/, "")}'"
          end
        end

      elsif val.is_a?(TrueClass)
        #::Chef::Log.info("#{key} is true")
        val = "on"

      elsif val.is_a?(FalseClass)
        #::Chef::Log.info("#{key} is false")
        val = "off"

      else
        if !val.is_a?(Integer) && !val.is_a?(Float)
          raise ::Errno::ENOENT.new("Unsupported config type at key #{key}")
        end
      end

      conf_line = "#{key} = #{val}"
      if @conf_lookup.has_key?(key)
        cb = @conf_lookup[key]
        if !cb[1].empty?
          conf_line += " ##{cb[1]}"
        end
        @conf_lines[cb[0]] = conf_line

      else
        @conf_lines << conf_line
        @conf_lookup[key] = [@conf_lines.length, ""]

      end

    end

    def update!(vals)
      vals.each do |key, val|
        self.set(key, val)
      end
    end

    # convert everything to a string so it can be written to a file
    #
    # @returns [string]: all the configuration in the format needed
    def to_s()
      return @conf_lines.join("\n") + "\n"
    end

  end


  # namespace for postgres specific static methods
  class Postgres

    ##
    # get the postgres version that will be installed if you ran apt-get, this is
    # handy because it allows you to get the version that will be installed so you
    # can figure out paths that Postgres will use
    ##
    def self.get_version()
      version_str = shell_out!("apt-cache show postgresql | grep Version")
      m = version_str.stdout.match(/^Version:\s*([\d\.]+)/i)
      return m[1]
    end

    def self.get_main_dir(version)
      return ::File.join("", "etc", "postgresql", version, "main")
    end

    def self.get_data_dir(version)
      return ::File.join("", "var", "lib", "postgresql", version, "main")
    end

    def self.get_system_conf_dir(version)
      return ::File.join("", "etc", "postgresql-common")
    end

    def self.get_conf_file(version)
      return ::File.join(self.get_main_dir(version), "postgresql.conf")
    end

    def self.get_confd_file(version, name)
      if !name.end_with?(".conf")
        name = "#{name}.conf"
      end
      return ::File.join(self.get_main_dir(version), "conf.d", name)
    end

    def self.get_hba_file(version)
      return ::File.join(self.get_main_dir(version), "pg_hba.conf")
    end

    # @returns [string]: the release version of the os, eg, bionic, trusty
    def self.get_os_release()
      output = shell_out!("lsb_release -sc")
      return output.stdout.strip()
    end

  end

  ##
  # creating an instance of this class will allow you to format queries and run
  # commands and check things on the db from the perspective of the passed in db
  # user
  ##
  class PostgresUser

    include ::Chef::Mixin::ShellOut

    attr_accessor :username, :cmd_user

    def initialize(username)
      @username = username

      # the reason why we do sudo -u postgres is because setting user "postgres"
      # doesn't work the way I thought it would work, so the only way to execute
      # these commands as the postgres user is to do the sudo hack
      @cmd_user = "sudo -u #{username}"
    end

    def pgpasses(options)
      # hostname:port:database:username:password
      pgpasses = options.fetch("pgpass", []).dup
      if pgpasses.count > 0
        pgpasses.map! { |pgpass|
          if pgpass.has_key?("hostname")
            pgpass["host"] ||= pgpass["hostname"]
          end
          pgpass["password"] ||= options.fetch("password", "*")
          pgpass["username"] ||= @username
          ["host", "port", "database"].each do |k|
            pgpass[k] ||= "*"
          end

          pgpass

        }

      else
        pgpasses << {
          "host" => "*",
          "port" => "*",
          "database" => "*",
          "password" => options.fetch("password", "*"),
          "username" => @username,
        }
      end

      p pgpasses
      return pgpasses

    end

    ##
    # return the home directory path of the initialized user
    ##
    def homedir()
      cmd = shell_out!("grep -e \"^#{username}:\" /etc/passwd | cut -d\":\" -f6")
      return cmd.stdout.strip
    end

    ##
    # return true if the given user already exists in the database
    ##
    def user_exists?(username)
      query = "select usename from pg_user where usename='#{username}'"
      #user_exists = "psql -c \"#{query}\" -d template1 | grep -w \"#{username}\""
      user_exists = "psql -c \"#{query}\" -d template1"
      ::Chef::Log.info(user_exists)
      cmd = shell_out!("#{@cmd_user} #{user_exists}", {:returns => [0]})
      #return cmd.stderr.empty? && (cmd.stdout =~ /\b#{username}\b/)
      return cmd.stdout =~ /\b#{username}\b/
    end

    ##
    # returns a command that can be run to create the username, the options are
    # specified in the chef configuration
    ##
    def create_user_command(username, options)
      cmd = "#{@cmd_user} psql -c \"#{make_user_query(username, options, true)}\" -d template1"
      ::Chef::Log.info(cmd)
      return cmd
    end

    ##
    # returns a command that can be run to update the username, the options are
    # specified in the chef configuration
    ##
    def update_user_command(username, options)
      cmd = "#{@cmd_user} psql -c \"#{make_user_query(username, options, false)}\" -d template1"
      ::Chef::Log.info(cmd)
      return cmd
    end

    ##
    # return true if the database exists
    ##
    def db_exists?(dbname)
      query = "select datname from pg_database where datname='#{dbname}'"
      db_exists = "psql -c \"#{query}\" -d template1 | grep -w \"#{dbname}\""
      ::Chef::Log.info(db_exists)
      cmd = shell_out!("#{@cmd_user} #{db_exists}", {:returns => [0, 1]})
      return cmd.stdout =~ /\b#{dbname}\b/
    end

    ##
    # returns a command to create a database, owned by owner (username)
    ##
    def create_db_command(dbname, owner, options)
      #encoding = options.fetch("encoding", "UTF8")
      #pg_locale = options.fetch("locale", "en_US.UTF-8")
      #cmd = "#{@cmd_user} createdb -E #{encoding} --locale=#{pg_locale} -O #{owner} #{dbname} --template=template0"

      #pg_locale = options.fetch("locale", "C.UTF-8")

      cmd = "#{@cmd_user} createdb"

      encoding = options.fetch("encoding", "")
      if !encoding.empty?
        cmd += " -E #{encoding}"
      end

      pg_locale = options.fetch("locale", "")
      if !pg_locale.empty?
        cmd += " --locale=#{pg_locale}"
      end

      # TODO -- if you change the locale and/or encoding we might need to switch template?

      cmd += " -O #{owner} #{dbname}"
      return cmd

#       encoding = options.fetch("encoding", "")
#       if encoding.empty?
#         encoding = self.get_default_encoding()
#       end
# 
#       pg_locale = options.fetch("locale", "")
#       if pg_locale.empty?
#         pg_locale = options.get_default_locale()
#       end
# 
#       cmd = "#{@cmd_user} createdb -E #{encoding} --locale=#{pg_locale} -O #{owner} #{dbname}"
# 
#       return cmd
    end

    # Return the encoding for the given db template
    #
    # @link https://stackoverflow.com/a/6477516/5006
    def get_default_encoding(template="template1")
      query = "SELECT pg_encoding_to_char(encoding) FROM pg_database WHERE datname='#{template}'"
      cmd = "#{@cmd_user} psql -qtAX -c \"#{query}\""
      return shell_out!(cmd).stdout.strip
    end

    # Return the collation and sorting locale for the given db template
    def get_default_locale(template="template1")
      query = "SELECT datcollate FROM pg_database WHERE datname='#{template}'"
      cmd = "#{@cmd_user} psql -qtAX -c \"#{query}\""
      return shell_out!(cmd).stdout.strip
    end

    ##
    # this returns the query, to be run on the given db (if provided), that you can
    # run on the command line
    ##
    def get_command(query, dbname="")
      if dbname.empty?
        cmd = "#{@cmd_user} psql -c \"#{query}\""
      else
        cmd = "#{@cmd_user} psql -d \"#{dbname}\" -c \"#{query}\""
      end
      return cmd
    end

    ##
    # this will create the query to either add or update the user's priviledges
    #
    # Originally this used createuser command line utility
    # http://www.postgresql.org/docs/9.3/static/app-createuser.html
    #
    # http://www.postgresql.org/docs/9.3/static/sql-createrole.html
    # http://www.postgresql.org/docs/9.3/static/sql-alterrole.html
    ##
    def make_user_query(username, user_options, is_create)

      options = user_options.fetch("options", {}).to_hash # just in case it's from the node
      if user_options.has_key?("password")
        options["ENCRYPTED PASSWORD"] = user_options["password"]
      end

      query = is_create ? "CREATE USER" : "ALTER USER"
      query += " #{username} WITH"
      opts = options.map { |k, v| [k.upcase, v] }.to_h

      opts.each do |k, v|
        if v.is_a?(TrueClass)
          query += " #{k}"

        elsif v.is_a?(FalseClass)
          query += " NO#{k}"

        elsif v.is_a?(Integer)
          query += " #{k} #{v}"

        else
          query += " #{k} '#{v}'"

        end

      end

      return query

    end

  end

end


# http://stackoverflow.com/questions/20835697/how-to-require-my-library-in-chef-ruby-block
#::Chef::Recipe.send(:include, Postgres::Helper)
#::Chef::Recipe.send(:include, Postgres)
::Chef::Recipe.send(:include, ::PostgresHelper)
# Chef::Resource.send(:include, ::Postgres::Helper)
# Chef::Provider.send(:include, ::Postgres::Helper)
#::Chef::Node::Attribute.send(:include, ::PostgresHelper)

